# author: 0xv1n
# Requirements: WinDbg (Classic) and pykd
# Searches specified memory range for POP POP RET sequences
import pykd
import argparse
import itertools

pop_opcodes = ["58", "59", "5A", "5C", "5D", "5E", "5F"]  # Excludes ESP opcode
ret_opcode = "C3"


def main():
    parser = argparse.ArgumentParser(description="Searches attached process for PPR.")
    parser.add_argument(
        "start_addr",
        type=str,
        help="Module starting address - find via lm m <mod_name> or narly",
    )
    parser.add_argument("end_addr", type=str, help="Module ending address")

    args = parser.parse_args()
    start_addr = args.start_addr
    end_addr = args.end_addr

    # Generate tuples of all possible opcode pairs
    pop_opcode_combos = list(itertools.combinations(pop_opcodes, 2))

    ppr_addrs = []
    for combo in pop_opcode_combos:
        try:
            # Use -[1] flag to only print addresses
            result = pykd.dbgCommand(
                f"s -[1]b {start_addr} {end_addr} {combo[0]} {combo[1]} {ret_opcode}"
            )
        except Exception as e:
            print(repr(e))
            continue

        if result:
            ppr_addrs.append(str(result).strip())

    print(ppr_addrs)  # TODO: Investigate inconsistencies in array data types.


if __name__ == "__main__":
    main()
